const crypto = require('node:crypto');
const { when } = require('jest-when');
const { CryptographicallyStrongGenerator } = require('./cryptographically-strong-generator');

jest.mock('node:crypto', () => ({
  randomBytes: jest.fn(),
}));

describe('CryptographicallyStrongGenerator', () => {
  let generator;

  beforeEach(() => {
    generator = new CryptographicallyStrongGenerator();
  });

  describe('randomBytes', () => {
    const numberOfBytes = 2;
    const hexStringOfTheRandomBytes = 'a1b2';
    const theRandomBytes = Buffer.from(hexStringOfTheRandomBytes, 'hex');

    it('returns the hex string of the bytes generated by crypto.randomBytes', () => {
      when(crypto.randomBytes).calledWith(numberOfBytes).mockReturnValueOnce(theRandomBytes);

      const randomHexString = generator.randomHexString(numberOfBytes);

      expect(randomHexString).toBe(hexStringOfTheRandomBytes);
    });
  });

  describe('randomHexString', () => {
    const numberOfBytes = 2;
    const hexStringOfTheRandomBytes = 'a1b2';
    const theRandomBytes = Buffer.from(hexStringOfTheRandomBytes, 'hex');

    it('returns the hex string of the bytes generated by crypto.randomBytes', () => {
      when(crypto.randomBytes).calledWith(numberOfBytes).mockReturnValueOnce(theRandomBytes);

      const randomHexString = generator.randomHexString(numberOfBytes);

      expect(randomHexString).toBe(hexStringOfTheRandomBytes);
    });
  });

  describe('validateHexString', () => {
    const numberOfBytes = 2;
    it('returns false if string is not hex and not of correct length', () => {
      const aNonHexStringOfIncorrectLength = 'testString';
      const result = generator.validateHexString({ numberOfBytes, inputString: aNonHexStringOfIncorrectLength });
      expect(result).toBe(false);
    });

    it('returns false if string is not hex', () => {
      const aNonHexStringOfCorrectLength = 'z0z0';
      const result = generator.validateHexString({ numberOfBytes, inputString: aNonHexStringOfCorrectLength });
      expect(result).toBe(false);
    });

    it('returns false if string is too short', () => {
      const aShortHexString = 'a1';
      const result = generator.validateHexString({ numberOfBytes, inputString: aShortHexString });
      expect(result).toBe(false);
    });

    it('returns false if string is too long', () => {
      const aLongHexString = 'a2b2c3';
      const result = generator.validateHexString({ numberOfBytes, inputString: aLongHexString });
      expect(result).toBe(false);
    });

    it('returns true if string is hex and correct length', () => {
      const aCorrectLengthHexString = 'a2b2';
      const result = generator.validateHexString({ numberOfBytes, inputString: aCorrectLengthHexString });
      expect(result).toBe(true);
    });
  });
});
