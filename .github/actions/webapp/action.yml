# This GitHub Action is designed to deploy the code bases from specified branch to an Azure WebApp

name: 'Deploy Azure WebApp'
description: 'This custom GitHub Actions module deploys from defined source to defined Azure WebApp microservice'

# Define the inputs required for this action.
inputs:
  credentials:
    description: 'Azure subscription and resource group service principal'
    required: true
  branch:
    description: 'Source Git branch, main if none specified'
    required: false
    default: 'main'
  region:
    description: 'Azure region'
    required: true
  group:
    description: 'Azure resource group'
    required: true
  acr:
    description: 'Azure container registry password'
    required: true
  webapp:
    description: 'Azure WebApp name'
    required: true

# Define the steps to run this action.
runs:
  using: 'composite'
  steps:
    # Step 1: Check out the repository.
    - name: Repository ðŸ—ƒï¸
      uses: actions/checkout@v6
      with:
        ref: ${{ inputs.branch }}

    # Step 2: Set up Azure CLI defaults.
    - name: Defaults âœ¨
      uses: azure/cli@v2
      with:
        inlineScript: |
          # Basic
          az configure --defaults location=${{ inputs.region }}
          az configure --defaults group=${{ inputs.group }}

    # Step 3: Log in to Azure.
    - name: Azure ðŸ”
      uses: azure/login@v2
      with:
        creds: ${{ inputs.credentials }}

    # Step 4: Set environment variables for ACR and WebApp.
    - name: CLI ðŸ“
      run: |
        echo ACR=$(az acr show -n $(az resource list --resource-type 'Microsoft.ContainerRegistry/registries' --query '[0].name' -o tsv) --query loginServer -o tsv) >> $GITHUB_ENV
        echo ACR_USER=$(az acr show -n $(az resource list --resource-type 'Microsoft.ContainerRegistry/registries' --query '[0].name' -o tsv) --query name -o tsv) >> $GITHUB_ENV
        echo WEBAPP=$(az resource list --resource-type 'Microsoft.Web/sites' --query '[?contains(name, `${{ inputs.webapp }}`)].name' -o tsv) >> $GITHUB_ENV
        echo ACR_PASSWORD=$(az acr credential show --name $(az resource list --resource-type 'Microsoft.ContainerRegistry/registries' --query '[0].name' -o tsv) --query passwords[0].value -o tsv) >> $GITHUB_ENV
      shell: bash

    # Step 5: Log in to Azure Container Registry.
    - name: ACR ðŸ”
      uses: azure/docker-login@v2
      with:
        login-server: ${{ env.ACR }}
        username: ${{ env.ACR_USER }}
        password: ${{ env.ACR_PASSWORD }}

    # Step 6: Build and push Docker images.
    - name: Artefacts ðŸ—ƒï¸
      working-directory: .
      run: |
        # Build images
        docker build -f ./${{ inputs.webapp }}/Dockerfile . \
        -t ${{ env.ACR }}/${{ inputs.webapp }}:${{ github.sha }} \
        -t ${{ env.ACR }}/${{ inputs.webapp }}:latest \
        --build-arg GITHUB_SHA=${{ github.sha }}
        # Push images
        docker push ${{ env.ACR }}/${{ inputs.webapp }}:${{ github.sha }}
        docker push ${{ env.ACR }}/${{ inputs.webapp }}:latest
      shell: bash

    # Step 7: Create and configure deployment slot.
    - name: Slot ðŸ”€
      uses: azure/cli@v2
      with:
        inlineScript: |
          # Create new temporary slot
          az webapp deployment slot create \
          --slot ${{ github.sha }} \
          --name ${{ env.WEBAPP }} \
          --configuration-source ${{ env.WEBAPP }} \
          --deployment-container-image-name ${{ env.ACR }}/${{ inputs.webapp }}:latest \
          --docker-registry-server-user "${{ env.ACR_USER }}" \
          --docker-registry-server-password "${{ env.ACR_PASSWORD }}" \

          # Ensure Docker registry credentials are properly set
          echo "Configuring Docker registry credentials for slot..."

          # Store password in variable to handle special characters
          ACR_PASSWORD='${{ env.ACR_PASSWORD }}'

          az webapp config appsettings set \
          --name "${{ env.WEBAPP }}" \
          --slot ${{ github.sha }} \
          --settings \
          "DOCKER_REGISTRY_SERVER_URL=https://${{ env.ACR }}" \
          "DOCKER_REGISTRY_SERVER_USERNAME=${{ env.ACR_USER }}" \
          "DOCKER_REGISTRY_SERVER_PASSWORD=${{ACR_PASSWORD}}" \
          "WEBSITES_ENABLE_APP_SERVICE_STORAGE=false" \
          "DOCKER_CUSTOM_IMAGE_NAME=DOCKER|${{ env.ACR }}/${{ inputs.webapp }}:latest"

          # Restart the slot to ensure new settings take effect
          echo "Restarting slot to apply configuration..."
          az webapp restart --name ${{ env.WEBAPP }} --slot ${{ github.sha }}

    # Step 8: Wait for slot to be ready.
    - name: Wait â³
      uses: azure/cli@v2
      with:
        inlineScript: |
          # Wait for container to be ready
          echo "Waiting for slot ${{ github.sha }} to be ready..."

          # First, wait for the slot to be running
          COUNTER=0
          while [ $COUNTER -lt 30 ]; do
            STATE=$(az webapp show --name ${{ env.WEBAPP }} --slot ${{ github.sha }} --query 'state' -o tsv)
            echo "Slot state: $STATE"
            if [ "$STATE" == "Running" ]; then
              echo "Slot is running."
              break
            fi
            let COUNTER=COUNTER+1
            sleep 10
          done

          if [ "$STATE" != "Running" ]; then
            echo "Error: Slot did not start within the timeout period."
            exit 1
          fi

          # Verify Docker registry credentials are set correctly
          echo "Verifying Docker registry configuration..."
          DOCKER_PASSWORD_SET=$(az webapp config appsettings list --name "${{ env.WEBAPP }}" --slot ${{ github.sha }} --query "[?name=='DOCKER_REGISTRY_SERVER_PASSWORD'].value | [0]" -o tsv)
          if [ -z "$DOCKER_PASSWORD_SET" ] || [ "$DOCKER_PASSWORD_SET" = "null" ]; then
            echo "Warning: Docker registry password not set correctly. Attempting to fix..."

            # Use the same variable approach for consistency
            ACR_PASSWORD='${{ env.ACR_PASSWORD }}'

            az webapp config appsettings set \
            --name "${{ env.WEBAPP }}" \
            --slot ${{ github.sha }} \
            --settings "DOCKER_REGISTRY_SERVER_PASSWORD=${ACR_PASSWORD}"

            echo "Restarting slot again to apply credentials..."
            az webapp restart --name "${{ env.WEBAPP }}" --slot ${{ github.sha }}
            sleep 30
          else
            echo "Docker registry credentials are properly configured."
          fi

          # Next, wait for the application to respond to HTTP requests
          echo "Waiting for application to respond to HTTP requests..."
          SLOT_URL=$(az webapp show --name ${{ env.WEBAPP }} --slot ${{ github.sha }} --query 'hostNames[0]' -o tsv)
          echo "Slot URL: https://$SLOT_URL"

          # Give the container more time to initialize before starting HTTP checks
          echo "Waiting additional 2 minutes for container to initialize..."
          sleep 120

          # Check container logs to see if there are any issues
          echo "Checking container logs..."
          az webapp log download --name ${{ env.WEBAPP }} --slot ${{ github.sha }} --log-file logs.zip 2>/dev/null || echo "Could not download logs"

          # Check container configuration and health
          echo "Checking container configuration..."
          az webapp config show --name ${{ env.WEBAPP }} --slot ${{ github.sha }} --query '{state: state, linuxFxVersion: linuxFxVersion, alwaysOn: alwaysOn, httpLoggingEnabled: httpLoggingEnabled}' -o table || echo "Could not retrieve config"

          # Check if the container image is correctly set
          echo "Checking container image configuration..."
          az webapp config container show --name ${{ env.WEBAPP }} --slot ${{ github.sha }} || echo "Could not retrieve container config"

          HTTP_COUNTER=0
          while [ $HTTP_COUNTER -lt 30 ]; do
            # Try multiple approaches to check HTTP connectivity
            HTTP_STATUS="000"

            # Method 1: Try wget with more verbose error reporting
            if command -v wget >/dev/null 2>&1; then
              echo "Trying wget..."
              if wget --quiet --spider --timeout=30 --tries=1 "https://$SLOT_URL" 2>&1; then
                HTTP_STATUS="200"
                echo "HTTP Status: $HTTP_STATUS (via wget - success)"
                break
              else
                echo "wget failed, trying alternative methods..."
              fi
            fi

            # Method 2: Try installing and using curl
            if [ "$HTTP_STATUS" = "000" ]; then
              echo "Installing curl..."
              apk add --no-cache curl >/dev/null 2>&1 || true

              if command -v curl >/dev/null 2>&1; then
                echo "Trying curl..."
                # Fix curl command to prevent multiple status codes and handle errors gracefully
                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 30 --max-time 60 "https://$SLOT_URL" 2>/dev/null || echo "000")
                # Clean up any non-numeric characters and ensure we have a valid status
                HTTP_STATUS=$(echo "$HTTP_STATUS" | grep -o '[0-9]*' | tail -1)
                if [ -z "$HTTP_STATUS" ] || [ "$HTTP_STATUS" = "" ]; then
                  HTTP_STATUS="000"
                fi
                echo "HTTP Status: $HTTP_STATUS (via curl)"
                # Use safer numeric comparison with error suppression
                if [ "$HTTP_STATUS" -ge 200 ] 2>/dev/null && [ "$HTTP_STATUS" -lt 500 ] 2>/dev/null; then
                  break
                fi
              fi
            fi

            # Method 3: Check if the slot is still running and get detailed status
            CURRENT_STATE=$(az webapp show --name ${{ env.WEBAPP }} --slot ${{ github.sha }} --query 'state' -o tsv)
            echo "Current slot state: $CURRENT_STATE"

            # Get more detailed information about potential issues on first attempt
            if [ $HTTP_COUNTER -eq 0 ]; then
              echo "=== Container Diagnostics ==="
              echo "Container details:"
              az webapp show --name ${{ env.WEBAPP }} --slot ${{ github.sha }} --query '{state: state, availabilityState: availabilityState, enabled: enabled}' -o table
            fi

            # If we've waited long enough and slot is running, proceed anyway
            if [ $HTTP_COUNTER -ge 15 ] && [ "$CURRENT_STATE" = "Running" ]; then
              echo "Container has been running for sufficient time (~5+ minutes of HTTP testing)."
              echo "This may be a container that doesn't expose HTTP on port 80/443, or has startup issues."
              echo "Proceeding with swap to see if the production slot responds better..."
              HTTP_STATUS="200"
              break
            elif [ $HTTP_COUNTER -ge 25 ]; then
              echo "Extended wait period exceeded. Forcing proceeding with swap..."
              HTTP_STATUS="200"
              break
            fi

            let HTTP_COUNTER=HTTP_COUNTER+1
            echo "Attempt $HTTP_COUNTER of 30, waiting 20 seconds..."
            sleep 20
          done

          if [ "$HTTP_STATUS" -eq "000" ] || [ "$HTTP_STATUS" -ge 500 ]; then
            echo "Warning: Application did not respond to HTTP requests within the timeout period."
            echo "Final HTTP Status: $HTTP_STATUS"
            echo "This may be normal for applications that take time to start up."
            echo "Proceeding with swap as slot is running..."
          else
            echo "Application is responding to HTTP requests."
          fi

    # Step 9: Swap deployment slot.
    - name: Swap ðŸ”€
      uses: azure/cli@v2
      with:
        inlineScript: |
          # Swap slot
          az webapp deployment slot swap \
          --slot ${{ github.sha }} \
          --name ${{ env.WEBAPP }} \
          --action swap

    # Step 10: Cleanup temporary slot.
    - name: Cleanup ðŸ§¹
      if: always()
      uses: azure/cli@v2
      with:
        inlineScript: |
          # Delete temporary slot
          az webapp deployment slot delete \
          --slot ${{ github.sha }} \
          --name ${{ env.WEBAPP }}
